/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type APIConfigObservation struct {
}

type APIConfigParameters struct {

	// Indicates if it's possible to establish connections based on the given service profile using the Equinix Fabric API.
	// +kubebuilder:validation:Optional
	APIAvailable *bool `json:"apiAvailable,omitempty" tf:"api_available,omitempty"`

	// Setting showing that oversubscription support is available (true) or not (false). The default is false
	// +kubebuilder:validation:Optional
	AllowOverSubscription *bool `json:"allowOverSubscription,omitempty" tf:"allow_over_subscription,omitempty"`

	// Indicates if the connection bandwidth can be obtained directly from the cloud service provider.
	// +kubebuilder:validation:Optional
	BandwidthFromAPI *bool `json:"bandwidthFromApi,omitempty" tf:"bandwidth_from_api,omitempty"`

	// Setting indicating that the port is managed by Equinix (true) or not (false)
	// +kubebuilder:validation:Optional
	EquinixManagedPort *bool `json:"equinixManagedPort,omitempty" tf:"equinix_managed_port,omitempty"`

	// Setting indicating that the VLAN is managed by Equinix (true) or not (false)
	// +kubebuilder:validation:Optional
	EquinixManagedVlan *bool `json:"equinixManagedVlan,omitempty" tf:"equinix_managed_vlan,omitempty"`

	// A unique identifier issued during onboarding and used to integrate the customer's service profile with the Equinix Fabric API.
	// +kubebuilder:validation:Optional
	IntegrationID *string `json:"integrationId,omitempty" tf:"integration_id,omitempty"`

	// Port bandwidth multiplier that determines the total bandwidth that can be allocated to users creating connections to your services. For example, a 10 Gbps port combined with an overSubscriptionLimit parameter value of 10 allows your subscribers to create connections with a total bandwidth of 100 Gbps.
	// +kubebuilder:validation:Optional
	OverSubscriptionLimit *float64 `json:"overSubscriptionLimit,omitempty" tf:"over_subscription_limit,omitempty"`
}

type AuthenticationKeyObservation struct {
}

type AuthenticationKeyParameters struct {

	// Description of authorization key
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Name of the parameter that must be provided to authorize the connection.
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Requirement to configure an authentication key.
	// +kubebuilder:validation:Optional
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`
}

type CustomFieldsObservation struct {
}

type CustomFieldsParameters struct {

	// Required field
	// +kubebuilder:validation:Optional
	CaptureInEmail *bool `json:"captureInEmail,omitempty" tf:"capture_in_email,omitempty"`

	// Data type
	// +kubebuilder:validation:Required
	DataType *string `json:"dataType" tf:"data_type,omitempty"`

	// Description
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Label
	// +kubebuilder:validation:Required
	Label *string `json:"label" tf:"label,omitempty"`

	// Options
	// +kubebuilder:validation:Optional
	Options []*string `json:"options,omitempty" tf:"options,omitempty"`

	// Required field
	// +kubebuilder:validation:Required
	Required *bool `json:"required" tf:"required,omitempty"`
}

type LinkProtocolConfigObservation struct {
}

type LinkProtocolConfigParameters struct {

	// Data frames encapsulation standard.UNTAGGED - Untagged encapsulation for EPL connections. DOT1Q - DOT1Q encapsulation standard. QINQ - QINQ encapsulation standard.
	// +kubebuilder:validation:Optional
	Encapsulation *string `json:"encapsulation,omitempty" tf:"encapsulation,omitempty"`

	// Additional tagging information required by the seller profile.
	// +kubebuilder:validation:Optional
	EncapsulationStrategy *string `json:"encapsulationStrategy,omitempty" tf:"encapsulation_strategy,omitempty"`

	// Automatically accept subsequent DOT1Q to QINQ connections that use the same authentication key. These connections will have the same VLAN S-tag assigned as the initial connection.
	// +kubebuilder:validation:Optional
	ReuseVlanSTag *bool `json:"reuseVlanSTag,omitempty" tf:"reuse_vlan_s_tag,omitempty"`
}

type MarketingInfoObservation struct {
}

type MarketingInfoParameters struct {

	// Logo
	// +kubebuilder:validation:Optional
	Logo *string `json:"logo,omitempty" tf:"logo,omitempty"`

	// Process Step
	// +kubebuilder:validation:Optional
	ProcessStep []ProcessStepParameters `json:"processStep,omitempty" tf:"process_step,omitempty"`

	// Promotion
	// +kubebuilder:validation:Optional
	Promotion *bool `json:"promotion,omitempty" tf:"promotion,omitempty"`
}

type MetrosObservation struct {
}

type MetrosParameters struct {

	// Metro Code - Example SV
	// +kubebuilder:validation:Optional
	Code *string `json:"code,omitempty" tf:"code,omitempty"`

	// Display Name
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// IBX- Equinix International Business Exchange list
	// +kubebuilder:validation:Optional
	Ibxs []*string `json:"ibxs,omitempty" tf:"ibxs,omitempty"`

	// In Trail
	// +kubebuilder:validation:Optional
	InTrail *bool `json:"inTrail,omitempty" tf:"in_trail,omitempty"`

	// Metro Name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Seller Regions
	// +kubebuilder:validation:Optional
	SellerRegions map[string]*string `json:"sellerRegions,omitempty" tf:"seller_regions,omitempty"`
}

type PortsLocationObservation struct {
}

type PortsLocationParameters struct {

	// IBX Code
	// +kubebuilder:validation:Optional
	Ibx *string `json:"ibx,omitempty" tf:"ibx,omitempty"`

	// Access point metro code
	// +kubebuilder:validation:Optional
	MetroCode *string `json:"metroCode,omitempty" tf:"metro_code,omitempty"`

	// Access point metro name
	// +kubebuilder:validation:Optional
	MetroName *string `json:"metroName,omitempty" tf:"metro_name,omitempty"`

	// Access point region
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type PortsObservation struct {
}

type PortsParameters struct {

	// Cross Connect Id
	// +kubebuilder:validation:Optional
	CrossConnectID *string `json:"crossConnectId,omitempty" tf:"cross_connect_id,omitempty"`

	// Colo/Port Location
	// +kubebuilder:validation:Optional
	Location []PortsLocationParameters `json:"location,omitempty" tf:"location,omitempty"`

	// Seller Region
	// +kubebuilder:validation:Optional
	SellerRegion *string `json:"sellerRegion,omitempty" tf:"seller_region,omitempty"`

	// Seller Region details
	// +kubebuilder:validation:Optional
	SellerRegionDescription *string `json:"sellerRegionDescription,omitempty" tf:"seller_region_description,omitempty"`

	// Colo/Port Type
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// Colo/Port Uuid
	// +kubebuilder:validation:Required
	UUID *string `json:"uuid" tf:"uuid,omitempty"`
}

type ProcessStepObservation struct {
}

type ProcessStepParameters struct {

	// Description
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Sub Title
	// +kubebuilder:validation:Optional
	SubTitle *string `json:"subTitle,omitempty" tf:"sub_title,omitempty"`

	// Title
	// +kubebuilder:validation:Optional
	Title *string `json:"title,omitempty" tf:"title,omitempty"`
}

type ServiceProfileAccessPointTypeConfigsObservation struct {

	// Colo/Port Uuid
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type ServiceProfileAccessPointTypeConfigsParameters struct {

	// Api configuration details
	// +kubebuilder:validation:Optional
	APIConfig []APIConfigParameters `json:"apiConfig,omitempty" tf:"api_config,omitempty"`

	// Setting to enable or disable the ability of the buyer to change connection bandwidth without approval of the seller
	// +kubebuilder:validation:Optional
	AllowBandwidthAutoApproval *bool `json:"allowBandwidthAutoApproval,omitempty" tf:"allow_bandwidth_auto_approval,omitempty"`

	// Availability of a bandwidth upgrade. The default is false
	// +kubebuilder:validation:Optional
	AllowBandwidthUpgrade *bool `json:"allowBandwidthUpgrade,omitempty" tf:"allow_bandwidth_upgrade,omitempty"`

	// Setting to enable or disable the ability of the buyer to customize the bandwidth
	// +kubebuilder:validation:Optional
	AllowCustomBandwidth *bool `json:"allowCustomBandwidth,omitempty" tf:"allow_custom_bandwidth,omitempty"`

	// Setting to allow or prohibit remote connections to the service profile
	// +kubebuilder:validation:Optional
	AllowRemoteConnections *bool `json:"allowRemoteConnections,omitempty" tf:"allow_remote_connections,omitempty"`

	// Authentication key details
	// +kubebuilder:validation:Optional
	AuthenticationKey []AuthenticationKeyParameters `json:"authenticationKey,omitempty" tf:"authentication_key,omitempty"`

	// Percentage of port bandwidth at which an allocation alert is generated
	// +kubebuilder:validation:Optional
	BandwidthAlertThreshold *float64 `json:"bandwidthAlertThreshold,omitempty" tf:"bandwidth_alert_threshold,omitempty"`

	// Custom name for Connection
	// +kubebuilder:validation:Optional
	ConnectionLabel *string `json:"connectionLabel,omitempty" tf:"connection_label,omitempty"`

	// Mandate redundant connections
	// +kubebuilder:validation:Optional
	ConnectionRedundancyRequired *bool `json:"connectionRedundancyRequired,omitempty" tf:"connection_redundancy_required,omitempty"`

	// Enable auto generate service key
	// +kubebuilder:validation:Optional
	EnableAutoGenerateServiceKey *bool `json:"enableAutoGenerateServiceKey,omitempty" tf:"enable_auto_generate_service_key,omitempty"`

	// Link protocol configuration details
	// +kubebuilder:validation:Optional
	LinkProtocolConfig []LinkProtocolConfigParameters `json:"linkProtocolConfig,omitempty" tf:"link_protocol_config,omitempty"`

	// Supported bandwidths
	// +kubebuilder:validation:Optional
	SupportedBandwidths []*float64 `json:"supportedBandwidths,omitempty" tf:"supported_bandwidths,omitempty"`

	// Type of access point type config - VD, COLO
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type ServiceProfileAccountObservation struct {
	AccountName *string `json:"accountName,omitempty" tf:"account_name,omitempty"`

	AccountNumber *float64 `json:"accountNumber,omitempty" tf:"account_number,omitempty"`

	GlobalCustID *string `json:"globalCustId,omitempty" tf:"global_cust_id,omitempty"`

	GlobalOrgID *string `json:"globalOrgId,omitempty" tf:"global_org_id,omitempty"`

	GlobalOrganizationName *string `json:"globalOrganizationName,omitempty" tf:"global_organization_name,omitempty"`

	OrgID *float64 `json:"orgId,omitempty" tf:"org_id,omitempty"`

	OrganizationName *string `json:"organizationName,omitempty" tf:"organization_name,omitempty"`

	UcmID *string `json:"ucmId,omitempty" tf:"ucm_id,omitempty"`
}

type ServiceProfileAccountParameters struct {
}

type ServiceProfileChangeLogObservation struct {
	CreatedBy *string `json:"createdBy,omitempty" tf:"created_by,omitempty"`

	CreatedByEmail *string `json:"createdByEmail,omitempty" tf:"created_by_email,omitempty"`

	CreatedByFullName *string `json:"createdByFullName,omitempty" tf:"created_by_full_name,omitempty"`

	CreatedDateTime *string `json:"createdDateTime,omitempty" tf:"created_date_time,omitempty"`

	DeletedBy *string `json:"deletedBy,omitempty" tf:"deleted_by,omitempty"`

	DeletedByEmail *string `json:"deletedByEmail,omitempty" tf:"deleted_by_email,omitempty"`

	DeletedByFullName *string `json:"deletedByFullName,omitempty" tf:"deleted_by_full_name,omitempty"`

	DeletedDateTime *string `json:"deletedDateTime,omitempty" tf:"deleted_date_time,omitempty"`

	UpdatedBy *string `json:"updatedBy,omitempty" tf:"updated_by,omitempty"`

	UpdatedByEmail *string `json:"updatedByEmail,omitempty" tf:"updated_by_email,omitempty"`

	UpdatedByFullName *string `json:"updatedByFullName,omitempty" tf:"updated_by_full_name,omitempty"`

	UpdatedDateTime *string `json:"updatedDateTime,omitempty" tf:"updated_date_time,omitempty"`
}

type ServiceProfileChangeLogParameters struct {
}

type ServiceProfileNotificationsObservation struct {
}

type ServiceProfileNotificationsParameters struct {

	// Array of contact emails
	// +kubebuilder:validation:Required
	Emails []*string `json:"emails" tf:"emails,omitempty"`

	// Send interval
	// +kubebuilder:validation:Optional
	SendInterval *string `json:"sendInterval,omitempty" tf:"send_interval,omitempty"`

	// Notification Type - ALL,CONNECTION_APPROVAL,SALES_REP_NOTIFICATIONS, NOTIFICATIONS
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type ServiceProfileObservation struct {

	// Access point config information
	// +kubebuilder:validation:Optional
	AccessPointTypeConfigs []ServiceProfileAccessPointTypeConfigsObservation `json:"accessPointTypeConfigs,omitempty" tf:"access_point_type_configs,omitempty"`

	// Service Profile Owner Account Information
	Account []ServiceProfileAccountObservation `json:"account,omitempty" tf:"account,omitempty"`

	// Captures connection lifecycle change information
	ChangeLog []ServiceProfileChangeLogObservation `json:"changeLog,omitempty" tf:"change_log,omitempty"`

	// Service Profile URI response attribute
	Href *string `json:"href,omitempty" tf:"href,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Project information
	// +kubebuilder:validation:Optional
	Project []ServiceProfileProjectObservation `json:"project,omitempty" tf:"project,omitempty"`

	// Equinix assigned service profile identifier
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type ServiceProfileParameters struct {

	// Access point config information
	// +kubebuilder:validation:Optional
	AccessPointTypeConfigs []ServiceProfileAccessPointTypeConfigsParameters `json:"accessPointTypeConfigs,omitempty" tf:"access_point_type_configs,omitempty"`

	// Array of contact emails
	// +kubebuilder:validation:Optional
	AllowedEmails []*string `json:"allowedEmails,omitempty" tf:"allowed_emails,omitempty"`

	// Custom Fields
	// +kubebuilder:validation:Optional
	CustomFields []CustomFieldsParameters `json:"customFields,omitempty" tf:"custom_fields,omitempty"`

	// User-provided service description
	// +kubebuilder:validation:Required
	Description *string `json:"description" tf:"description,omitempty"`

	// Marketing Info
	// +kubebuilder:validation:Optional
	MarketingInfo []MarketingInfoParameters `json:"marketingInfo,omitempty" tf:"marketing_info,omitempty"`

	// Access point config information
	// +kubebuilder:validation:Optional
	Metros []MetrosParameters `json:"metros,omitempty" tf:"metros,omitempty"`

	// Customer-assigned service profile name
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Preferences for notifications on connection configuration or status changes
	// +kubebuilder:validation:Optional
	Notifications []ServiceProfileNotificationsParameters `json:"notifications,omitempty" tf:"notifications,omitempty"`

	// Ports
	// +kubebuilder:validation:Optional
	Ports []PortsParameters `json:"ports,omitempty" tf:"ports,omitempty"`

	// Project information
	// +kubebuilder:validation:Optional
	Project []ServiceProfileProjectParameters `json:"project,omitempty" tf:"project,omitempty"`

	// Self Profile indicating if the profile is created for customer's  self use
	// +kubebuilder:validation:Optional
	SelfProfile *bool `json:"selfProfile,omitempty" tf:"self_profile,omitempty"`

	// Service profile state - ACTIVE, PENDING_APPROVAL, DELETED, REJECTED
	// +kubebuilder:validation:Optional
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Tags attached to the connection
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Service profile type - L2_PROFILE, L3_PROFILE, ECIA_PROFILE, ECMC_PROFILE
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// Virtual Devices
	// +kubebuilder:validation:Optional
	VirtualDevices []VirtualDevicesParameters `json:"virtualDevices,omitempty" tf:"virtual_devices,omitempty"`

	// Service profile visibility - PUBLIC, PRIVATE
	// +kubebuilder:validation:Optional
	Visibility *string `json:"visibility,omitempty" tf:"visibility,omitempty"`
}

type ServiceProfileProjectObservation struct {

	// Unique Resource URL
	Href *string `json:"href,omitempty" tf:"href,omitempty"`
}

type ServiceProfileProjectParameters struct {

	// Project Id
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`
}

type VirtualDevicesLocationObservation struct {
}

type VirtualDevicesLocationParameters struct {

	// IBX Code
	// +kubebuilder:validation:Optional
	Ibx *string `json:"ibx,omitempty" tf:"ibx,omitempty"`

	// Access point metro code
	// +kubebuilder:validation:Optional
	MetroCode *string `json:"metroCode,omitempty" tf:"metro_code,omitempty"`

	// Access point metro name
	// +kubebuilder:validation:Optional
	MetroName *string `json:"metroName,omitempty" tf:"metro_name,omitempty"`

	// Access point region
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type VirtualDevicesObservation struct {
}

type VirtualDevicesParameters struct {

	// Device Interface Uuid
	// +kubebuilder:validation:Optional
	InterfaceUUID *string `json:"interfaceUuid,omitempty" tf:"interface_uuid,omitempty"`

	// Device Location
	// +kubebuilder:validation:Optional
	Location []VirtualDevicesLocationParameters `json:"location,omitempty" tf:"location,omitempty"`

	// Virtual Device Type
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// Virtual Device Uuid
	// +kubebuilder:validation:Required
	UUID *string `json:"uuid" tf:"uuid,omitempty"`
}

// ServiceProfileSpec defines the desired state of ServiceProfile
type ServiceProfileSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ServiceProfileParameters `json:"forProvider"`
}

// ServiceProfileStatus defines the observed state of ServiceProfile.
type ServiceProfileStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ServiceProfileObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ServiceProfile is the Schema for the ServiceProfiles API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,equinix}
type ServiceProfile struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ServiceProfileSpec   `json:"spec"`
	Status            ServiceProfileStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServiceProfileList contains a list of ServiceProfiles
type ServiceProfileList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ServiceProfile `json:"items"`
}

// Repository type metadata.
var (
	ServiceProfile_Kind             = "ServiceProfile"
	ServiceProfile_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ServiceProfile_Kind}.String()
	ServiceProfile_KindAPIVersion   = ServiceProfile_Kind + "." + CRDGroupVersion.String()
	ServiceProfile_GroupVersionKind = CRDGroupVersion.WithKind(ServiceProfile_Kind)
)

func init() {
	SchemeBuilder.Register(&ServiceProfile{}, &ServiceProfileList{})
}
