/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ReservedIPBlockInitParameters struct {

	// Only valid as an argument and required when type is vrf. The size of the network to reserve from an existing VRF ip_range. cidr can only be specified with vrf_id. Range is 22-31. Virtual Circuits require 30-31. Other VRF resources must use a CIDR in the 22-29 range.
	// the size of the network to reserve from an existing vrf ip_range. `cidr` can only be specified with `vrf_id`. Minimum range is 22-29, with 30-31 supported and necessary for virtual-circuits
	Cidr *float64 `json:"cidr,omitempty" tf:"cidr,omitempty"`

	// This may be helpful for self-managed IPAM. The object must be valid JSON. This may be helpful for self-managed IPAM. The object must be valid JSON.
	CustomData *string `json:"customData,omitempty" tf:"custom_data,omitempty"`

	// Arbitrary description.
	// Arbitrary description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Deprecated) Facility where to allocate the public IP address block, makes sense only if type is public_ipv4 and must be empty if type is global_ipv4. Conflicts with metro. Use metro instead; read the facility to metro migration guide
	// Facility where to allocate the public IP address block, makes sense only for type==public_ipv4, must be empty for type==global_ipv4, conflicts with metro
	Facility *string `json:"facility,omitempty" tf:"facility,omitempty"`

	// Metro where to allocate the public IP address block, makes sense only if type is public_ipv4 and must be empty if type is global_ipv4. Conflicts with facility.
	// Metro where to allocate the public IP address block, makes sense only for type==public_ipv4, must be empty for type==global_ipv4, conflicts with facility
	Metro *string `json:"metro,omitempty" tf:"metro,omitempty"`

	// Only valid as an argument and required when type is vrf. An unreserved network address from an existing ip_range in the specified VRF.
	// an unreserved network address from an existing vrf ip_range. `network` can only be specified with vrf_id
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// The metal project ID where to allocate the address block.
	// The metal project ID where to allocate the address block
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-equinix/apis/metal/v1alpha1.Project
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Reference to a Project in metal to populate projectId.
	// +kubebuilder:validation:Optional
	ProjectIDRef *v1.Reference `json:"projectIdRef,omitempty" tf:"-"`

	// Selector for a Project in metal to populate projectId.
	// +kubebuilder:validation:Optional
	ProjectIDSelector *v1.Selector `json:"projectIdSelector,omitempty" tf:"-"`

	// The number of allocated /32 addresses, a power of 2. Required when type is not vrf.
	// The number of allocated /32 addresses, a power of 2
	Quantity *float64 `json:"quantity,omitempty" tf:"quantity,omitempty"`

	// String list of tags.
	// Tags attached to the reserved block
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// One of global_ipv4, public_ipv4, or vrf. Defaults to public_ipv4 for backward compatibility.
	// Either global_ipv4, public_ipv4, or vrf. Defaults to public_ipv4.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Only valid and required when type is vrf. VRF ID for type=vrf reservations.
	// VRF ID for type=vrf reservations
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-equinix/apis/metal/v1alpha1.Vrf
	VrfID *string `json:"vrfId,omitempty" tf:"vrf_id,omitempty"`

	// Reference to a Vrf in metal to populate vrfId.
	// +kubebuilder:validation:Optional
	VrfIDRef *v1.Reference `json:"vrfIdRef,omitempty" tf:"-"`

	// Selector for a Vrf in metal to populate vrfId.
	// +kubebuilder:validation:Optional
	VrfIDSelector *v1.Selector `json:"vrfIdSelector,omitempty" tf:"-"`

	// Wait for the IP reservation block to reach a desired state on resource creation. One of: pending, created. The created state is default and recommended if the addresses are needed within the configuration. An error will be returned if a timeout or the denied state is encountered.
	// Wait for the IP reservation block to reach a desired state on resource creation. One of: `pending`, `created`. The `created` state is default and recommended if the addresses are needed within the configuration. An error will be returned if a timeout or the `denied` state is encountered.
	WaitForState *string `json:"waitForState,omitempty" tf:"wait_for_state,omitempty"`
}

type ReservedIPBlockObservation struct {
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// Address family as integer. One of 4 or 6.
	// Address family as integer (4 or 6)
	AddressFamily *float64 `json:"addressFamily,omitempty" tf:"address_family,omitempty"`

	// Only valid as an argument and required when type is vrf. The size of the network to reserve from an existing VRF ip_range. cidr can only be specified with vrf_id. Range is 22-31. Virtual Circuits require 30-31. Other VRF resources must use a CIDR in the 22-29 range.
	// the size of the network to reserve from an existing vrf ip_range. `cidr` can only be specified with `vrf_id`. Minimum range is 22-29, with 30-31 supported and necessary for virtual-circuits
	Cidr *float64 `json:"cidr,omitempty" tf:"cidr,omitempty"`

	// Address and mask in CIDR notation, e.g. 147.229.15.30/31.
	CidrNotation *string `json:"cidrNotation,omitempty" tf:"cidr_notation,omitempty"`

	// This may be helpful for self-managed IPAM. The object must be valid JSON. This may be helpful for self-managed IPAM. The object must be valid JSON.
	CustomData *string `json:"customData,omitempty" tf:"custom_data,omitempty"`

	// Arbitrary description.
	// Arbitrary description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Deprecated) Facility where to allocate the public IP address block, makes sense only if type is public_ipv4 and must be empty if type is global_ipv4. Conflicts with metro. Use metro instead; read the facility to metro migration guide
	// Facility where to allocate the public IP address block, makes sense only for type==public_ipv4, must be empty for type==global_ipv4, conflicts with metro
	Facility *string `json:"facility,omitempty" tf:"facility,omitempty"`

	Gateway *string `json:"gateway,omitempty" tf:"gateway,omitempty"`

	// Boolean flag whether addresses from a block are global (i.e. can be assigned in any metro).
	// Flag indicating whether IP block is global, i.e. assignable in any location
	Global *bool `json:"global,omitempty" tf:"global,omitempty"`

	// The unique ID of the block.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Manageable *bool `json:"manageable,omitempty" tf:"manageable,omitempty"`

	Management *bool `json:"management,omitempty" tf:"management,omitempty"`

	// Metro where to allocate the public IP address block, makes sense only if type is public_ipv4 and must be empty if type is global_ipv4. Conflicts with facility.
	// Metro where to allocate the public IP address block, makes sense only for type==public_ipv4, must be empty for type==global_ipv4, conflicts with facility
	Metro *string `json:"metro,omitempty" tf:"metro,omitempty"`

	// Mask in decimal notation, e.g. 255.255.255.0.
	// Mask in decimal notation, e.g. 255.255.255.0
	Netmask *string `json:"netmask,omitempty" tf:"netmask,omitempty"`

	// Only valid as an argument and required when type is vrf. An unreserved network address from an existing ip_range in the specified VRF.
	// an unreserved network address from an existing vrf ip_range. `network` can only be specified with vrf_id
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// The metal project ID where to allocate the address block.
	// The metal project ID where to allocate the address block
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Boolean flag whether addresses from a block are public.
	// Flag indicating whether IP block is addressable from the Internet
	Public *bool `json:"public,omitempty" tf:"public,omitempty"`

	// The number of allocated /32 addresses, a power of 2. Required when type is not vrf.
	// The number of allocated /32 addresses, a power of 2
	Quantity *float64 `json:"quantity,omitempty" tf:"quantity,omitempty"`

	// String list of tags.
	// Tags attached to the reserved block
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// One of global_ipv4, public_ipv4, or vrf. Defaults to public_ipv4 for backward compatibility.
	// Either global_ipv4, public_ipv4, or vrf. Defaults to public_ipv4.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Only valid and required when type is vrf. VRF ID for type=vrf reservations.
	// VRF ID for type=vrf reservations
	VrfID *string `json:"vrfId,omitempty" tf:"vrf_id,omitempty"`

	// Wait for the IP reservation block to reach a desired state on resource creation. One of: pending, created. The created state is default and recommended if the addresses are needed within the configuration. An error will be returned if a timeout or the denied state is encountered.
	// Wait for the IP reservation block to reach a desired state on resource creation. One of: `pending`, `created`. The `created` state is default and recommended if the addresses are needed within the configuration. An error will be returned if a timeout or the `denied` state is encountered.
	WaitForState *string `json:"waitForState,omitempty" tf:"wait_for_state,omitempty"`
}

type ReservedIPBlockParameters struct {

	// Only valid as an argument and required when type is vrf. The size of the network to reserve from an existing VRF ip_range. cidr can only be specified with vrf_id. Range is 22-31. Virtual Circuits require 30-31. Other VRF resources must use a CIDR in the 22-29 range.
	// the size of the network to reserve from an existing vrf ip_range. `cidr` can only be specified with `vrf_id`. Minimum range is 22-29, with 30-31 supported and necessary for virtual-circuits
	// +kubebuilder:validation:Optional
	Cidr *float64 `json:"cidr,omitempty" tf:"cidr,omitempty"`

	// This may be helpful for self-managed IPAM. The object must be valid JSON. This may be helpful for self-managed IPAM. The object must be valid JSON.
	// +kubebuilder:validation:Optional
	CustomData *string `json:"customData,omitempty" tf:"custom_data,omitempty"`

	// Arbitrary description.
	// Arbitrary description
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Deprecated) Facility where to allocate the public IP address block, makes sense only if type is public_ipv4 and must be empty if type is global_ipv4. Conflicts with metro. Use metro instead; read the facility to metro migration guide
	// Facility where to allocate the public IP address block, makes sense only for type==public_ipv4, must be empty for type==global_ipv4, conflicts with metro
	// +kubebuilder:validation:Optional
	Facility *string `json:"facility,omitempty" tf:"facility,omitempty"`

	// Metro where to allocate the public IP address block, makes sense only if type is public_ipv4 and must be empty if type is global_ipv4. Conflicts with facility.
	// Metro where to allocate the public IP address block, makes sense only for type==public_ipv4, must be empty for type==global_ipv4, conflicts with facility
	// +kubebuilder:validation:Optional
	Metro *string `json:"metro,omitempty" tf:"metro,omitempty"`

	// Only valid as an argument and required when type is vrf. An unreserved network address from an existing ip_range in the specified VRF.
	// an unreserved network address from an existing vrf ip_range. `network` can only be specified with vrf_id
	// +kubebuilder:validation:Optional
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// The metal project ID where to allocate the address block.
	// The metal project ID where to allocate the address block
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-equinix/apis/metal/v1alpha1.Project
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Reference to a Project in metal to populate projectId.
	// +kubebuilder:validation:Optional
	ProjectIDRef *v1.Reference `json:"projectIdRef,omitempty" tf:"-"`

	// Selector for a Project in metal to populate projectId.
	// +kubebuilder:validation:Optional
	ProjectIDSelector *v1.Selector `json:"projectIdSelector,omitempty" tf:"-"`

	// The number of allocated /32 addresses, a power of 2. Required when type is not vrf.
	// The number of allocated /32 addresses, a power of 2
	// +kubebuilder:validation:Optional
	Quantity *float64 `json:"quantity,omitempty" tf:"quantity,omitempty"`

	// String list of tags.
	// Tags attached to the reserved block
	// +kubebuilder:validation:Optional
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// One of global_ipv4, public_ipv4, or vrf. Defaults to public_ipv4 for backward compatibility.
	// Either global_ipv4, public_ipv4, or vrf. Defaults to public_ipv4.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Only valid and required when type is vrf. VRF ID for type=vrf reservations.
	// VRF ID for type=vrf reservations
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-equinix/apis/metal/v1alpha1.Vrf
	// +kubebuilder:validation:Optional
	VrfID *string `json:"vrfId,omitempty" tf:"vrf_id,omitempty"`

	// Reference to a Vrf in metal to populate vrfId.
	// +kubebuilder:validation:Optional
	VrfIDRef *v1.Reference `json:"vrfIdRef,omitempty" tf:"-"`

	// Selector for a Vrf in metal to populate vrfId.
	// +kubebuilder:validation:Optional
	VrfIDSelector *v1.Selector `json:"vrfIdSelector,omitempty" tf:"-"`

	// Wait for the IP reservation block to reach a desired state on resource creation. One of: pending, created. The created state is default and recommended if the addresses are needed within the configuration. An error will be returned if a timeout or the denied state is encountered.
	// Wait for the IP reservation block to reach a desired state on resource creation. One of: `pending`, `created`. The `created` state is default and recommended if the addresses are needed within the configuration. An error will be returned if a timeout or the `denied` state is encountered.
	// +kubebuilder:validation:Optional
	WaitForState *string `json:"waitForState,omitempty" tf:"wait_for_state,omitempty"`
}

// ReservedIPBlockSpec defines the desired state of ReservedIPBlock
type ReservedIPBlockSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ReservedIPBlockParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ReservedIPBlockInitParameters `json:"initProvider,omitempty"`
}

// ReservedIPBlockStatus defines the observed state of ReservedIPBlock.
type ReservedIPBlockStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ReservedIPBlockObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ReservedIPBlock is the Schema for the ReservedIPBlocks API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,equinix}
type ReservedIPBlock struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ReservedIPBlockSpec   `json:"spec"`
	Status            ReservedIPBlockStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ReservedIPBlockList contains a list of ReservedIPBlocks
type ReservedIPBlockList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ReservedIPBlock `json:"items"`
}

// Repository type metadata.
var (
	ReservedIPBlock_Kind             = "ReservedIPBlock"
	ReservedIPBlock_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ReservedIPBlock_Kind}.String()
	ReservedIPBlock_KindAPIVersion   = ReservedIPBlock_Kind + "." + CRDGroupVersion.String()
	ReservedIPBlock_GroupVersionKind = CRDGroupVersion.WithKind(ReservedIPBlock_Kind)
)

func init() {
	SchemeBuilder.Register(&ReservedIPBlock{}, &ReservedIPBlockList{})
}
